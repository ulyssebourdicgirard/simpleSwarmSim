import os
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from matplotlib.animation import FuncAnimation, PillowWriter
from config import ARENA_RADIUS, NEIGHBORS

def generate_interactive_html(log_path, pos, phi, vz, params):
    import plotly.graph_objects as go

    suffix = "3D"
    output_html = os.path.join(log_path, f"animation_{suffix}_interactive.html")
    
    step = 4
    pos_sub = pos[::step]
    phi_sub = phi[::step]
    vz_sub = vz[::step]

    u_init = np.cos(phi_sub[0])
    v_init = np.sin(phi_sub[0])
    w_init = vz_sub[0]

    fig = go.Figure(
        data=[go.Cone(
            x=pos_sub[0, :, 0],
            y=pos_sub[0, :, 1],
            z=pos_sub[0, :, 2],
            u=u_init,
            v=v_init,
            w=w_init,
            sizemode="absolute",
            sizeref=2.0,
            anchor="tail",
            colorscale="Blues",
            showscale=False
        )]
    )

    frames = []
    for t in range(len(pos_sub)):
        frames.append(go.Frame(
            data=[go.Cone(
                x=pos_sub[t, :, 0],
                y=pos_sub[t, :, 1],
                z=pos_sub[t, :, 2],
                u=np.cos(phi_sub[t]),
                v=np.sin(phi_sub[t]),
                w=vz_sub[t]
            )],
            name=str(t)
        ))
    
    fig.frames = frames

    sliders = [dict(
        active=0,
        yanchor="top",
        xanchor="left",
        currentvalue=dict(font=dict(size=14), prefix="Frame : ", visible=True, xanchor="right"),
        transition=dict(duration=0), # 0 pour Ã©viter le lag d'interpolation
        pad=dict(b=10, t=50),
        len=0.9,
        x=0.1,
        y=0,
        steps=[dict(
            args=[[str(k)], dict(frame=dict(duration=0, redraw=True), transition=dict(duration=0), mode="immediate")],
            label=str(k * step), 
            method="animate"
        ) for k in range(len(pos_sub))]
    )]

    fig.update_layout(
        title=f"Replay Interactif 3D : y_att={params.get('y_att', 0):.2f}",
        uirevision='constant', # --- LE FIX DE LA CAMERA MAGIQUE ---
        scene=dict(
            xaxis=dict(range=[-ARENA_RADIUS, ARENA_RADIUS]),
            yaxis=dict(range=[-ARENA_RADIUS, ARENA_RADIUS]),
            zaxis=dict(range=[0, 15]),
            aspectmode='manual',
            aspectratio=dict(x=1, y=1, z=0.5)
        ),
        updatemenus=[dict(
            type="buttons",
            showactive=False,
            y=0,
            x=0.05,
            xanchor="right",
            yanchor="top",
            pad=dict(t=50, r=10),
            buttons=[
                dict(
                    label="Play (Normale)",
                    method="animate",
                    args=[None, dict(frame=dict(duration=100, redraw=True), transition=dict(duration=0), fromcurrent=True, mode="immediate")]
                ),
                dict(
                    label="Play (Rapide)",
                    method="animate",
                    args=[None, dict(frame=dict(duration=20, redraw=True), transition=dict(duration=0), fromcurrent=True, mode="immediate")]
                ),
                dict(
                    label="Pause",
                    method="animate",
                    args=[[None], dict(frame=dict(duration=0, redraw=False), mode="immediate", transition=dict(duration=0))]
                )
            ]
        )],
        sliders=sliders
    )

    fig.write_html(output_html)

def generate_gif_from_log(log_path):
    """
    Visualization bridge.
    Reads the trajectory.npz file generated by the Logger and creates a GIF.
    """
    import config
    suffix = "3D" if config.ENABLE_3D else "2D"
    trajectory_file = os.path.join(log_path, f"trajectory_{suffix}.npz")
    
    if not os.path.exists(trajectory_file):
        trajectory_file = os.path.join(log_path, "trajectory.npz")
        
    if not os.path.exists(trajectory_file):
        print(f"[Visu] Error: No trajectory file in {log_path}")
        return

    print(f"[Visu] Loading {trajectory_file}...")
    data = np.load(trajectory_file, allow_pickle=True)
    
    pos = data['pos'] 
    phi = data['phi'] 
    
    params = data['params'].item() 
    
    fig = plt.figure(figsize=(8, 8))
    title = f"Replay: y_att={params['y_att']:.2f}, Neigh={params.get('NEIGHBORS', NEIGHBORS)}"
    
    if config.ENABLE_3D:
        ax = fig.add_subplot(111, projection='3d')
        theta_circle = np.linspace(0, 2*np.pi, 100)
        
        def update_3d(frame):
            ax.cla()
            ax.set_xlim(-ARENA_RADIUS-1, ARENA_RADIUS+1)
            ax.set_ylim(-ARENA_RADIUS-1, ARENA_RADIUS+1)
            ax.set_zlim(0, 10)
            ax.set_title(title)
            ax.plot(ARENA_RADIUS * np.cos(theta_circle), ARENA_RADIUS * np.sin(theta_circle), 0, color='r', ls='--', alpha=0.5)
            
            px = pos[frame, :, 0]
            py = pos[frame, :, 1]
            pz = pos[frame, :, 2]
            
            dx = np.cos(phi[frame])
            dy = np.sin(phi[frame])
            dz = data['vz'][frame] if 'vz' in data.files else np.zeros_like(dx)
            
            ax.quiver(px, py, pz, dx, dy, dz, length=2, normalize=True, color='dodgerblue')
            return ax,
            
        ani = FuncAnimation(fig, update_3d, frames=len(pos), interval=30, blit=False)
        
    else:
        ax = fig.add_subplot(111)
        ax.set_xlim(-ARENA_RADIUS-1, ARENA_RADIUS+1)
        ax.set_ylim(-ARENA_RADIUS-1, ARENA_RADIUS+1)
        ax.add_patch(Circle((0, 0), ARENA_RADIUS, color='r', fill=False, ls='--', alpha=0.5))
        
        ax.set_title(title)
        ax.set_aspect('equal')
        ax.grid(True, alpha=0.2)

        quiver = ax.quiver(pos[0, :, 0], pos[0, :, 1], 
                           np.cos(phi[0]), np.sin(phi[0]), 
                           color='dodgerblue', scale=25, width=0.005)

        def update(frame):
            quiver.set_offsets(pos[frame])
            quiver.set_UVC(np.cos(phi[frame]), np.sin(phi[frame]))
            return quiver,

        ani = FuncAnimation(fig, update, frames=len(pos), interval=30, blit=True)
    
    output_gif = os.path.join(log_path, f"animation_{suffix}.gif")
    print(f"[Visu] Generating GIF: {output_gif} (patience...)")
    
    writer = PillowWriter(fps=30)
    ani.save(output_gif, writer=writer)
    plt.close(fig) 
    
    if config.ENABLE_3D:
        vz_data = data['vz'] if 'vz' in data.files else np.zeros_like(phi)
        generate_interactive_html(log_path, pos, phi, vz_data, params)
        
    print("[Visu] Done.")

if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        generate_gif_from_log(sys.argv[1])
    else:
        print("Usage: python visualization.py logs/DIR_NAME")